
	封装：

	封装是指：将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。
	封装是面向对象贬称语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接直接操作和修改，就比如类中的Person
	对象的age变量，只能随着岁月的流逝，age才会增加，通常不能岁月修改属性的值，良好的封装有以下特点：

	1：隐藏类的实现细节
	2：让使用者只能通过实现预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问
	3:可进行数据检查，从而利用保证对象信息的完整性。
	4：便于修改，提供代码的可复用性和维护性


	最重要的两条就是：
	a:把对象的成员变量和实现细节隐藏起来，不允许外部直接访问
	b:把方法暴露出来，让方法控制对这些成员变量进行安全的访问和操作。
	这样做的目的就是为了统一行径，可以在方法中加入控制逻辑。




	继承：
	继承是面向对象的三大特征之一，也是实现软件复用的重要手段，Java具有单继承的特点每个子类只有一个直接父类。
	Java中的基础是通过extends关键字来实现的，实现继承的类称为子类，被继承的类被称为父类（超类，基类，大类）
	例如苹果继承了水果，苹果是子类，水果是父类。

	继承是把很多子类中相同的成员属性和方法定义父类的过程。

	super
	一定要有继承关系（父子关系）前提下，才会有super的概念
	当前类如果没有继承关系，执行一定的Object
	如果有继承关系，一定执行父类的引用和父类构造函数

	---他们都成员属性赋值操作

	给成员属性赋值一下：
	1：修饰符
	2:你属性是static,不是对象的范畴，调用类去调用

	3:final 值赋值一次
	4:final修饰的方法，不能被重写的方法.
	5:final --不管针对的是成员变量还是局部变量，一定赋值就不能修改----常量
		成员变量：
			修饰的非静态成员变量，赋值的方式有三种：
				1：直接赋值
				2：通过代码块赋值
				3：通过构造函数
			如果是静态成员：
			    1：直接赋值
			    2：静态代码块赋值

		局部变量：
		  1:直接赋值
		  2：可以不用赋初始值，但是只能赋值一次，赋值以后不能修改.
		  比如：
		  public void test(){
		  	final int age ;
		  	age = 10;
		  	//age = 20;//error，编译通不过
		  }










	多态：（存在继承的前提下）
	Java引用变量有有两个类型，一个是编译时的类型，一个是运行时的类型，编译时的类型由申明该变量时使用类型决定
	运行时的类型有实际赋给该变量的对象决定，
	如果编译时的类型和运行时的类型不一致的时候，就出现了所谓的多态。
	注：多态的实例只能调用被子类覆盖的部分和父类公开和受保护以及同包下面缺省的成员变量和方法。


	访问修饰符总结： public > protected > default >private
	1:public private忽略它
	2:同包中：缺省的，protected只要在同一片文件夹下面（平级的类），可以被访问的
	3:不同包中：protected 一定是父子关系的情况下才能被访问成员属性和方法


	抽象类：
	 *  不能实现化对象，但是可以定义构造函数.
	 *  实现抽象类，方式有两种---一种:通过匿名内部类，一种是：具体子类
	 *  1:抽象类必须使用abstract修饰，抽象方法必须用abstract修饰，抽象方法中不能又具体的实现。
	 *  2:抽象类不能被实例化对象的，但是可以定义构造函数，目的是给当前抽象类的私有成员属性赋值目的。（注：一种:通过匿名内部类，一种是：具体子类）
	 *  3：抽象方法，必须定义在抽象类中或者接口中。如果有抽象方法就要必然是抽象类或者接口。
	 *  4:final不能够abstract共用
	 *  5:不能私有private 可以是public protected
	 *  6:没有抽象属性的概念
	 *  7:抽象类可以继承抽象类，也可以继承普通类，也可以实现接口.
	1:是语义上的角度来看，抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象，从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其字类的
	模板，从而子类设计的随意性。
	2:抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展，改造，但子类总体上回大致保留抽象类的行为方式。
	3:如果编写一个抽象父类，父类提供多个子类的通用方法，并把一个或多个方法留给器子类实现，这就是模板模式，
	4:如果父类中定义的普通方法一般都是给所有子类调用的方法，或者私有方法给自己调用的方法。
	5:抽象方法的类一定抽象类，抽象类不一定有抽象方法



	接口：
	定义格式：--接口的命名I开头
	[修饰符] interface 接口名称 extends 父接口1
	{
		//零到多个常量定义
		//零到多个抽象方法定义
		//零到多个默认方法或类方法定义
		//零到多个内部类，接口，枚举定义....

	}

	抽象类是从多个类中抽象出来的模板，如果将这种抽象进行更彻底，那么就是--接口（interface）
	1:接口中不能包含普通方法，接口里的所有方法都是抽象方法，（jdk1.8后对接口进行了改进吗，允许定义默认方法，默认方法可以提供方法的实现。）
	2:接口是从多个相似类中抽象出来的规范，接口不提供任何实现，接口体现的是规范和实现分离的设计哲学。
	3:接口让规范和实现分离，正是接口的好处，让软件系统的各组件之间面向接口耦合，是一种松耦合的设计。例如主机板上提供了一个pci插槽，只要一个显卡遵守PCI接口规范
	就可以插入PCI插槽内。与主机板正常通信，至于这块显卡是哪个厂商制造的，内部是如何实现的，主板无须关心。
	类似的软件系统的各模块之间也应该采用这种面向接口
	耦合，从而尽量降低个模板之间的耦合，为系统提供更好的可扩展性和可维护性。

	4:接口不能继承抽象类和类，只能继承接口
	5:修饰符可以是public或者缺省的 ,默认采用缺省的访问修饰符。级只有在相同包结构下才可以访问接口方法。






	接口和抽象类：
	相同点：
	1：接口和抽象类都不能被实例化，它们都位于继承结构中的最顶端，用于被其他类实现和继承。
	2：接口和抽象类中都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

	不同点：
	1：接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类可以有普通方法提供方法实现。
	2：接口只能定义静态常量，不能定义成普通成员变量，抽象都可以。
	3：接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成抽象类成员
	属性赋值和初始化的目的。
	4：接口不能包含代码块，抽象类中可以包含代码块。
	5：一个类最大只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口来弥补Java中单继承的概念


	接口和类公共写作完成了：Java中的单一继承，多实现的概念，单一继承指的是类和类（抽象类的）继承，实现讲的是接口。







	变量  数据类型   数组 字符串  集合 Map Set

	类   抽象类   接口   内部类()
		成员属性
		方法 (重写和重载)
		静态快  代码
		（访问修饰符，static ,final 抽象方法， 静态快 super this ）



	进阶知识点：
	 反射 注解   枚举  泛型





	/*会话处理*/
	function setSession(key,value,mark){
		var stroage = mark?sessionStorage:localStorage;
		if(stroage)stroage.setItem(key, value);
	};


	function getSession(key,mark){
		var stroage = mark?sessionStorage:localStorage;
		if(stroage){
			return stroage.getItem(key);
		}else{
			return "";
		}
	};

	function removeSession(key,mark){
		var stroage = mark?sessionStorage:localStorage;
		if(stroage){
			return stroage.removeItem(key);
		}else{
			return "";
		}
	};
