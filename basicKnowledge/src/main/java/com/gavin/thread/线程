

	1：几乎所有的操作系统都支持进程的概念，所有运行中的任务通常对应一个进程，当一个程序进入到内存运行时，即变成一个进程，进程是处于运行过程中的
	程序，并且具有一定的独立功能，进程系统进行资源分配和调度的一个独立单元。
	一般而言，进程包含如下三个特征：
	a:独立性 进程是系统中独立存在的实体，它可以拥有自己的独立的资源，每一个进程都拥有自己私有的地址空间。
	b:动态性 进程与程序的区别在于，程序值是一个静态的指令集合，进程是一个真该系统中活动的指令集合，在进程中加入了时间的概念，进程具有自己的声明周期和各种不同的状态。
	c:并发性 多个进程可以在单个处理器上并发执行，多个进程之间不会互相影响。

	对于一个cpu而言，它在某个时间点只能执行一个程序，也就是说，只能运行一个进程，CPU在不断第在这些进程之间轮换执行，为什么用户感觉不到任何中断现象，是因为CPU执行
	的速度相对于人的感觉来说太快了。

	线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程，线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，单不拥有系统资源，他与父进程的其他线程共享该进程所
	拥有的全部资源，因为多个线程共享父进程里的全部资源。

	归纳起来就：操作系统可以执行多个任务，每个任务就是一个进程，进程可以同时执行多个任务，每个任务就是线程。


	线程的创建和启动：

	A: 继承Thread类来创建并启动多线程的步骤如下：
	1:定义Thread类的子类，并重写该类的run()方法，该run方法的方法体代表了线程需要完成的任务，因此把run方法称为线程的执行体。
	2:定义Thread子类的实例，即创建了线程对象
	3:通过调用线程对象的start()方法来启动该线程。

	B：实现Runnable接口来创建并启动多线程如下：
	1:定义类实现Runnable接口的实现类，并重写该接口的run方法，
	2:创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是正真的线程对象，
	3：调用线程对象的start来启动线程


	继承thread和实现runnable的对比：

	Runnable
	1:线程类实现了Runnable接口，还可以继承其他的类来扩展其业务.
	2:在这种方式下，多个线程可以共享同一个target对象，索引非常适合多个相同线程来处理同一份资源，从而可以将cpu,代码和数据分开，形成清晰的模型，较好地体现面向对象的思想
	  缺点：编程赋值，如果需要访问当前线程，则必须使用Thread.currentThread();

	 Thread
	3:编写简单，如下需要访问当前线程，则无须使用Thread.currentThread(),直接通过this即可获取当前线程。
	缺点啊：不能扩展业务，不能继承其他父类。

	推荐使用:Runnable接口的方式



	线程的生命周期:
	当线程被床以后，它既不是一个启动就进入执行状态，也不是一致处于执行状态，它必须经历：
	新建---->就绪----->运行---->阻塞---->死亡  五种状态.
	尤其是当线程启动以后，它不可能一致霸占着cpu独自运行，而是cpu需要在多线程之间切换。



	多线程版本的：

		多人聊天室(scoket和多线程)---调用每一个线程方法是为什么，为什么要这调用有和意义.



